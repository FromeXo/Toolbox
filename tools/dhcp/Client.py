from base64 import b16encode
from socket import inet_ntoa
from tools.dhcp.Options import OPTION_LIST

class Client:

    def __init__(self, data):

        # Hardware Type: Specifies the type of hardware used for the local network.
        # Value     Type
        # 1     Ethernet 10mb
        # 6     IEEE 802 Networks
        # 7     ARCNET
        # 11    LocalTalk
        # 12    LocalNet
        # 14    SMDS
        # 15    Frame Relay
        # 15    Async Transfer Mode
        # 17    HDLC
        # 18    Fibre Channel
        # 19    Async Transfer Mode
        # 20    Serial Line
        self.HTYPE = data[0][1]
        
        # Hardware Address Length: Specifies how long hardware addresses are in this message.
        # For Ethernet or other networks using IEEE 802 MAC addresses, the value is 6.
        self.HLEN = data[0][2]

        # Hops: Set to 0 by a client before transmitting a request.
        # Used by relay agents to control the forwarding of BOOTP and/or DHCP messages.
        self.HOPS = data[0][3]

        # Transaction Identifier: A 32-bit identification field generated by the client.
        # To allow it to match up the request with replies received from DHCP servers.
        self.XID = int.from_bytes(data[0][4:8], "big")

        # Seconds: The number of seconds elapsed since a client began an attempt to acquire or renew a lease.
        # This may be used by a busy DHCP server to prioritize replies when multiple client requests are outstanding.
        self.SECS = int.from_bytes(data[0][8:10], "big")

        # Flags: 
        self.FLAGS = data[0][10:12]

        # Client IP Address: 
        self.CIADDR = inet_ntoa(data[0][12:16])

        # “Your” IP Address: The IP address that the server is assigning to the client.
        self.YIADDR = inet_ntoa(data[0][16:20])

        # Server IP Address: The address of the server that the client should use for the next step in the bootstrap process,
        # which may or may not be the server sending this reply.
        self.SIADDR = inet_ntoa(data[0][20:24])

        # Gateway IP Address: This field is not used by clients and does not represent the server giving the client the address of a default router
        self.GIADDR = inet_ntoa(data[0][24:28])

        offset = 28 + self.HLEN
        # Client Hardware Address: The hardware (layer two) address of the client
        self.CHADDR = self.to_mac(data[0][28:offset])

        self.CHADDRP = data[0][offset:offset+10]

        offset += 10

        # Server Name: The server sending a DHCPOFFER or DHCPACK message
        self.SNAME = data[0][offset:offset+64].decode("ascii")
        
        offset += 64

        # Boot Filename: Optionally used by a client to request a particular type of boot file in a DHCPDISCOVER message.
        # Used by a server in a DHCPOFFER to fully specify a boot file directory path and filename.
        file = b16encode(data[0][offset:offset+128])
        self.FILE = file.decode('ASCII')

        offset += 128

        self.magic_cookie = inet_ntoa(data[0][offset:offset+4])

        offset += 4

        # Options: Holds DHCP options, including several parameters required for basic DHCP operation.
        self.OPTIONS = {}

        while True:
            # Offset bigger then the amount of data to offset? What is this? Communism?
            if offset > len(data[0]):
                break

            # One byte containing option type number
            opt_type = int.from_bytes(data[0][offset:offset+1], "big")
            offset += 1

            # Option type number 255 means end of option list
            if opt_type == 255:
                break

            # Option lengh, how long the data portion of the option is.
            opt_len = int.from_bytes(data[0][offset:offset+1], "big")
            offset += 1

            # Option data
            opt_data = data[0][offset:offset + opt_len]
            offset += opt_len

            # From opt_type get name
            name = OPTION_LIST[opt_type][0]

            # If the data can be parsed in any way
            if OPTION_LIST[opt_type][1] is not None:
                # Parse the data
                opt_data = OPTION_LIST[opt_type][1](opt_data)

            # Update that shit untill the next end of tomorrowy
            self.OPTIONS.update({name: opt_data})



    def to_mac(self, data):
        hex = b16encode(data)
        ret = "{}:{}:{}:{}:{}".format(
            hex[0:2].decode("ascii"),
            hex[2:4].decode("ascii"),
            hex[4:6].decode("ascii"),
            hex[8:10].decode("ascii"),
            hex[10:12].decode("ascii"))
        return ret